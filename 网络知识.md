### 1. TCP建立连接的三次握手
[参考：简单的例子](https://blog.csdn.net/qq_35860138/article/details/82054793)

TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己。

张三：向李四招手

李四：微笑（代表确认），并向张三招手

张三：微笑（代表确认）

两人就可以快速走到一起并交流
![tcp三次握手过程](./Image/tcpthree1.png)
![tcp三次握手过程](./Image/tcpthree.png)

第一次握手：当客户端需要去建立连接时，客户端就会发送SYN包（seq=x）到服务器，然后客户端进入SYN_SEND的状态，代表已经发SYN包过去，并且在等待服务器确认。此时ACK=0,SYN=1.，这时候由于才第一次握手，所以没有ACK标志

第二次握手：服务器收到SYN包，就会进行确认，由上面的标志位介绍我们可以知道SYN是表示同步序号，这时候会使得确认号=序号+1，即ack就会等于x+1，然后服务器也会像客户端发送一个SYN包（seq=y），这时候也就是服务器会发送SYN+ACK包，来表示服务器确认到了客户端的一次握手并且二次握手建立，此时服务器进入SYN_RECV状态。此时SYN=1，ACK=1，这时候由于是第二次握手，所以就会有一个服务器给客户端的确认标志。

第三次握手：客户端收到服务器的SYN+ACK包，然后就会像服务器发送确认包ACK（ack=k+1）和SYN（seq=x+1），等到这个包发送完毕之后客户端和服务器就会进入ESTABLISHED状态，完成三次握手，而后就可以在服务端和客户端之间传输数据。此时SYN标志位已经不需要，因为当我们发送ACK标志位的时候代表三次握手成功，已经建立完连接了，接下来可以传送数据过去了。

- 既然都有SYN包那为什么还要ACK来确认呢？

    **SYN是同步序号，当 SYN=1 而ACK=0 时，表明这是一个连接请求报文**。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1。因此SYN置1就表示这是一个连接请求或连接接受报文。而ACK状态是用来确认是否同意连接。也就是传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。



- 为什么不能两次握手？| 两次握手演绎 

   第一步：客户端发送一个起始序列号seq = x的 报文段给服务器。
   
   第二步：服务器端返回向客户端发送确认号 ack = x+1，表示对客户端的起始序列号x 表示确认，并告诉客户端，他的起始序列号是 seq = y.
   
   所以，为什么不能两次握手？因为这种情况下，只有服务器对客户端的起始序列号做了确认，但客户端却没有对服务器的起始序列号做确认，不能保证传输的可靠性。



### 2. TCP断开连接的四次握手？可以三次么？为什么要4次？

![tcp](./Image/tcpfour1.png)

第一次握手：客户端发送一个FIN和序号过去（seq=u），用来表示客户端和服务端之间有关闭的请求，同时关闭客户端到服务端的数据传送，客户端就进入FIN_WAIT_1的状态。

第二次握手：服务端收到FIN=1的标志位时，就会发送一个ACK标志位代表确认，然后确认序号就变成了收到的序号加1，即ack=u+1（FIN和SYN在这点上相同，但是作用不一样）这时候服务端进入CLOSE_WAIT状态，这是一个半关闭状态。只能服务端给客户端发送数据而客户端不能给服务端发送数据。

第三次握手：这次握手还是由服务端发起，这是服务端在传完最后的数据（没有就不传）就会发送一个FIN=1和ACK=1，且序号seq会改变（没有传数据则不变），而ack不变。这时候服务端就会进入LAST_ACK状态，表示最后确认一次。

第四次握手：客户端在接收到FIN之后，就会进入TIME_WAIT状态，接着就发送一个ACK和seq=u+1,ack=w+1给服务端，这时候服务端就会进入CLOSED状态。而客户端进入TIME_WAIT状态的时候必须要等待2MSL的时间才会关闭

- 为什么三次？
    
    ![tcp三次握手过程](./Image/tcpfour.png)

    需要得到对方的确认,如果超过一定时间得不到确认会进行超时重传

    在等的这段时间，其实是要确保你的确认让对方收到，如果对方超时重传一个连接释放报文段，这个时候你还没有关闭，那你就可以重新发一个确认给他呀

    [简单的例子](https://blog.csdn.net/weixin_37891479/article/details/81012861)
- 为什么会有TIME_WAIT状态呢？（MSL：网络中数据报文存在的最大时间）   ---变相问题

    1、TIME_WAIT状态可以确保有足够的时间让对方接收到ACK包，如果ACK没有到达，在传输的过程丢失了或者一些其他原因，这样就可以让客户端重发ACK包。如果客户端直接关闭了，那么就有可能导致服务端在一些情况下没有接收到ACK包而无法与客户端断开连接。这样客户端发送ACK包到服务端，服务端请求重发，一来一回就正好是2MSL

    2、保证迟来的TCP报文段有足够的时间被识别并丢弃，linux 中一个TCPport不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会收到旧连接的数据。


- 为什么客户端最后还要等待2MSL？

    MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

    **第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失**，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

    第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。


参考链接：

[两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891) : 这个很详细

[TCP协议三次握手和四次握手机制-动画详解](https://blog.csdn.net/qq_35860138/article/details/82054793)

[TCP协议三次握手和四次握手](https://www.cnblogs.com/Cubemen/p/10803275.html)

[tcp断开连接为什么是4次挥手](https://blog.csdn.net/weixin_37891479/article/details/81012861)

[TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)